Just synthInput fed to Sketch

addAll
    val posExamplesAddAll = mutableListOf<Example>()
    posExamplesAddAll.add(Example(listOf(mutableListOf(1, 2, 3), listOf(5)), listOf(1, 2, 3, 5)))
    posExamplesAddAll.add(Example(listOf(mutableListOf(1, 2), listOf()), listOf(1, 2)))
    posExamplesAddAll.add(Example(listOf(mutableListOf(), listOf(3)), listOf(3)))
    val negExamplesAddAll = mutableListOf<Example>()
    negExamplesAddAll.add(Example(listOf(mutableListOf(1, 2), listOf(3)), listOf(1, 2, 3, 4)))
we get absolute garbage with squared terms, definitely not sound
but if we add
    posExamplesAddAll.add(Example(listOf(mutableListOf(1, 2, 3), listOf(5, 6, 7, 8)), listOf(1, 2, 3, 5, 6, 7, 8)))
we get
   0 <= ((((b + a) - c) * c) - 0)
   <=>
   c <= b + a
   sound, but not precise


add
    val posExamplesAdd = mutableListOf<Example>()
    posExamplesAdd.add(Example(listOf(mutableListOf(1, 2), 3), listOf(1, 2, 3)))
    posExamplesAdd.add(Example(listOf(mutableListOf<Int>(), 3), listOf(3)))

    val negExamplesAdd = mutableListOf<Example>()
    negExamplesAdd.add(Example(listOf(mutableListOf(1, 2), 3), listOf(1, 2, 3, 4)))
we get
    (o - (x - 0)) <= 1
    <=>
    o <= x + 1
    sound, but not precise


duplicate
    val posExamplesDup = mutableListOf<Example>()
    posExamplesDup.add(Example(listOf(listOf(1, 2)), listOf(1, 1, 2, 2)))
    posExamplesDup.add(Example(listOf(listOf<Int>()), listOf<Int>()))
    val negExamplesDup = mutableListOf<Example>()
    negExamplesDup.add(Example(listOf(listOf(1, 2)), listOf(1, 2)))
we get
    (o - ((x0 + 1) - o)) != 1
    <=>
    (o + o - x0) != 2
not sound: incorrect if x0 is length 1. Try again, and add :
    posExamplesDup.add(Example(listOf(listOf(1)), listOf(1, 1)))
we get
    ((0 - (2 * (1 - x0))) - 0) != o
    (-2 + 2 * x0) != o
    o is not twice the length of x0 minus 2. True, since o is twice the length of x0.
sound, but not precise.


these examples support our claim that positive examples improve soundness











make everything an int and just distinguish types myself?

more readable sketch maybe: create a sketch struct
struct Prog(x = ??, y = ??,...)
then prog = Prog
int interpret(int input, Prog p) that needs a parser

maybe can make genreator return struct who knows if will do the thing


assert 0 at end of concrete len
avoid uninterp maybe

Kevin OH. Is there anything really bad about using hard coded bottom instead of uninterpreted, if we'll never test it on something len isn't defined anyway?  Any way to build in preference for <,>. Yes but syntactic constraint less good. Think.... maybe we can prefer predicates that are false for other functions but true for this one. Like neg may. Ask sketch to minimize size of expr. Kevin can email the thing where he uses structs to make sketch print prettier